using System.Collections.Immutable;
using System.Diagnostics;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace SourceGenerator
{
    // ReSharper disable once UnusedTypeParameter
    public sealed class RegisterAs<T> : Attribute where T : class;

    [Generator]
    public class DependencyRegister : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            //if (!Debugger.IsAttached)
            //{
            //    Debugger.Launch();
            //}
            var provider = context.SyntaxProvider.CreateSyntaxProvider(
                (node, _) => HasRegisterAsAttribute(node),
                (node, _) => Transform(node)
            ).Where(x => x != null);

            var compilation = context.CompilationProvider.Combine(provider.Collect());
            context.RegisterSourceOutput(compilation, Execute);
        }

        private void Execute(SourceProductionContext arg1,
            (Compilation Left, ImmutableArray<TransformResult?> Right) arg2)
        {
            var (compilation, c) = arg2;
            if (c.Length == 0) return;

            HashSet<string> usings = [];
            HashSet<string> classesLooped = [];
            var autoGenerated = "// <auto-generated />";
            var firstPart = $$"""
                              namespace {{compilation.Assembly.Name}}.Services;
                              internal static class RegisterDependencies
                              {
                                public static IServiceCollection AddAutoGeneratedDependencies(this IServiceCollection services)
                                    => services
                              """;
            var lastPart = ";\n}";

            foreach (var (name, attribute, compilationUnitSyntax) in c)
            {
                if (attribute.Name is not GenericNameSyntax genericNameSyntax)
                    continue;
                usings.Add($"using {compilationUnitSyntax.GetNamespaceName()};");
                classesLooped.Add(
                    $"       .AddScoped<{genericNameSyntax.TypeArgumentList.Arguments.First().ToString()},{name}>()");
            }

            StringBuilder sb = new();
            sb.AppendLine(autoGenerated);
            sb.AppendLine(string.Join("\n", usings));
            sb.AppendLine(firstPart);
            sb.AppendLine(string.Join("\n", classesLooped));
            var final = sb.ToString().Substring(0, sb.Length-2) + lastPart;

            arg1.AddSource("RegisterDependenciesExtensions.g.cs", final);
        }


        private bool HasRegisterAsAttribute(SyntaxNode syntaxNode)
            => syntaxNode switch
            {
                ClassDeclarationSyntax classDeclarationSyntax
                    => HasRegisterAsAttribute(classDeclarationSyntax.AttributeLists),
                RecordDeclarationSyntax recordDeclarationSyntax
                    => HasRegisterAsAttribute(recordDeclarationSyntax.AttributeLists),
                _ => false
            };

        private bool HasRegisterAsAttribute(SyntaxList<AttributeListSyntax> attributeListSyntax)
            => attributeListSyntax.Any(x => x.Attributes.Any(c => c.Name is GenericNameSyntax
            {
                Identifier.Text: "RegisterAs"
            }));

        private TransformResult? Transform(GeneratorSyntaxContext context) =>
            context.Node switch
            {
                ClassDeclarationSyntax classDeclarationSyntax => new(classDeclarationSyntax.Identifier.ValueText,
                    GetRegisterAsAttribute(classDeclarationSyntax.AttributeLists),
                    classDeclarationSyntax.Parent!),
                RecordDeclarationSyntax recordDeclarationSyntax => new(recordDeclarationSyntax.Identifier.ValueText,
                    GetRegisterAsAttribute(recordDeclarationSyntax.AttributeLists),
                    (recordDeclarationSyntax.Parent!)),
                _ => null
            };

        private AttributeSyntax GetRegisterAsAttribute(SyntaxList<AttributeListSyntax> attributeListSyntax) =>
            attributeListSyntax
                .SelectMany(list => list.Attributes)
                .First(x => x.Name is GenericNameSyntax { Identifier.Text: "RegisterAs" });

        private class TransformResult(string name, AttributeSyntax attribute, SyntaxNode namespaceSyntax)
        {


            public string Name { get; } = name;
            public AttributeSyntax Attribute { get; } = attribute;
            public SyntaxNode NamespaceSyntax { get; } = namespaceSyntax;

            public void Deconstruct(out string name, out AttributeSyntax attribute, out SyntaxNode namespaceSyntax) =>
                (name, attribute, namespaceSyntax) = (Name, Attribute, NamespaceSyntax);
        }
    }
}