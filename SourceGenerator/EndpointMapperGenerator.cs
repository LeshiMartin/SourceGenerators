using System.Collections.Immutable;
using System.Diagnostics;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Diagnostics.CodeAnalysis;

namespace SourceGenerator;

public interface IEndpointMapper
{
}

public class Get([StringSyntax("Route")] string pattern) : Attribute;

public class Post([StringSyntax("Route")] string pattern) : Attribute;

public class Delete([StringSyntax("Route")] string pattern) : Attribute;

public class Put([StringSyntax("Route")] string pattern) : Attribute;

public class Patch([StringSyntax("Route")] string pattern) : Attribute;

[Generator]
public class EndpointMapperGenerator : IIncrementalGenerator
{
    private static readonly HashSet<string> EndpointAttributes =
    [
        nameof(Get),
        nameof(Post),
        nameof(Put),
        nameof(Patch),
        nameof(Delete)
    ];

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var provider = context.SyntaxProvider.CreateSyntaxProvider(
            (node, _) => node is ClassDeclarationSyntax classDeclarationSyntax && classDeclarationSyntax.BaseList?.Types
                .Select(x => x.ToString()).Any(x => x.Equals("IEndpointMapper")) == true,
            (ctx, _) => (ClassDeclarationSyntax)ctx.Node
        );

        var compilation = context.CompilationProvider.Combine(provider.Collect());
        context.RegisterSourceOutput(compilation, Execute);
    }

    private void Execute(SourceProductionContext context,
        (Compilation Left, ImmutableArray<ClassDeclarationSyntax> Right) arg2)
    {
        //if (!Debugger.IsAttached)
        //{
        //    Debugger.Launch();
        //}
        var (compilation, classes) = arg2;
        if (classes.IsEmpty) return;

        const string comment = "// autogenerated code";
        const string appBuilder = "routeBuilder";
        foreach (var @class in classes)
        {
            var sb = new StringBuilder().AppendLine(comment)
                .AppendLine($"namespace {@class.Parent!.GetNamespaceName()};");
            var modifier = @class.Modifiers[0].ToString();
            var body = $$"""
                         {{modifier}} partial class {{@class.Identifier.ToString()}}
                         {
                            public void MapEndpoints(IEndpointRouteBuilder {{appBuilder}})
                            {
                         """;
            sb.AppendLine(body);

            foreach (var method in @class.Members
                         .Where(x => HasValidAttribute(x.AttributeLists))
                         .OfType<MethodDeclarationSyntax>())
            {
                var attribute = method.AttributeLists.SelectMany(x => x.Attributes)
                    .First(x => EndpointAttributes.Contains(x.Name.ToString()))!;
                var pattern = attribute.ArgumentList!.Arguments[0].ToString();
                var (asyncStr, awaitStr) = GetAsyncStr(method);

                var (declarationArgs, argNames) = ArgList(method);
                var start = $$"""
                                      {{appBuilder}}.{{GetRouteMap(attribute)}}({{pattern}},{{asyncStr}} ({{declarationArgs}}) =>
                                         {
                                            logger.LogTrace("Handling {{method.Identifier.ToString()}}}");
                                            return {{awaitStr}} {{method.Identifier.ValueText}}({{argNames}});
                                         });
                              """;
                sb.AppendLine(start)
                    .AppendLine();
            }

            sb.AppendLine("    }")
                .AppendLine("}");

            var final = sb.ToString();
            context.AddSource($"{@class.Identifier.ToString()}Generated.g.cs", final);
        }
        context.AddSource($"MappingEndpointsGenerated.cs",
            ConstructExtensionMethod(compilation, classes));
    }

    private string ConstructExtensionMethod(Compilation compilation, ImmutableArray<ClassDeclarationSyntax> classes)
    {
        const string services = "services";
        var usings = string.Join("\n",
            classes.Select(x => $"using {x.Parent!.GetNamespaceName()};").OrderBy(x => x.Length));

        var sb = new StringBuilder()
            .AppendLine("// autogenerated code")
            .AppendLine($"namespace {compilation.Assembly.Name};")
            .AppendLine(usings);
        var start = $$"""
                      public static class EndpointMapperExtensions
                      {
                        public static WebApplication MapEndpoints(this WebApplication app)
                        {
                           using var scope = app.Services.CreateScope();
                           var {{services}} = scope.ServiceProvider;
                      """;
        sb.AppendLine(start);
        foreach (var @class in classes)
        {
            var className = @class.Identifier.ToString();
            sb.AppendLine($"     {services}.GetRequiredService<{className}>().MapEndpoints(app);");
        }

        sb.AppendLine("     return app;")
            .AppendLine("   }")
            .AppendLine("}");

        var final = sb.ToString();
        return final;
    }

    private static (string declarationArgs, string argNames) ArgList(MethodDeclarationSyntax method)
        => (
            declarationArgs: string.Join(",\n           ", method.ParameterList.Parameters.Select(x => x.ToString())),
            string.Join(",", method.ParameterList.Parameters.Select(x => x.Identifier.ToString())));

    private static bool HasValidAttribute(SyntaxList<AttributeListSyntax> attributesSyntaxList)
        => attributesSyntaxList.Any(x => x.Attributes.Any(atr => EndpointAttributes.Contains(atr.Name.ToString())));

    private static string GetRouteMap(AttributeSyntax attributeSyntax)
        => attributeSyntax.Name.ToString() switch
        {
            nameof(Get) => "MapGet",
            nameof(Post) => "MapPost",
            nameof(Put) => "MapPut",
            nameof(Patch) => "MapPatch",
            nameof(Delete) => "MapDelete",
            _ => throw new ArgumentOutOfRangeException()
        };

    private static (string asyncStr, string awaitStr) GetAsyncStr(MethodDeclarationSyntax method)
    {
        var isAsync = IsAsyncMethod(method);
        var asyncStr = isAsync ? "async" : "";
        var awaitStr = isAsync ? "await" : "";
        return (asyncStr, awaitStr);
    }

    private static bool IsAsyncMethod(MethodDeclarationSyntax method)
    {
        var methodName = method.Identifier.ToString();
        return method.Modifiers.Any(x => x.ToString() == "async") || methodName == "Task" || methodName == "ValueTask";
    }
}