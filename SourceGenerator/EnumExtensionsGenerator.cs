using System;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Text;
using System.Xml.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace SourceGenerator;

public class EnumExtensions : Attribute;

public class EnumName(string Name) : Attribute;

public class EnumDescription(string Description) : Attribute;

[Generator]
public class EnumExtensionsGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var provider = context.SyntaxProvider.CreateSyntaxProvider(
            (node, _) => node is EnumDeclarationSyntax @enum && @enum.AttributeLists
                .Any(x => x.Attributes.Any(at =>
                    at.Name
                        .ToString()
                        .Equals("EnumExtensions", StringComparison.InvariantCultureIgnoreCase))),
            (node, _) => (EnumDeclarationSyntax)node.Node
        ).Where(x => x is not null);

        var compilation = context.CompilationProvider.Combine(provider.Collect());
        context.RegisterSourceOutput(compilation, Execute!);
    }

    private void Execute(SourceProductionContext context,
        (Compilation Left, ImmutableArray<EnumDeclarationSyntax> Right) arg2)
    {
        //if (!Debugger.IsAttached)
        //{
        //    Debugger.Launch();
        //}
        var (s, enums) = arg2;
        if (enums.IsEmpty) return;
        var sb = new StringBuilder().AppendLine("// <auto-generated/>\n");
        var @namespace = $"namespace {s.AssemblyName};";
        var usings = new HashSet<string>();
        var classSb = new StringBuilder()
            .AppendLine("""
                        public static class GeneratedEnumExtensions
                        {
                        """);

        foreach (var @enum in enums)
        {
            usings.Add("using " + @enum.Parent!.GetNamespaceName(s.AssemblyName!) + ";");
            classSb
                .AppendLine(@enum.GetNameMethod())
                .AppendLine(@enum.GetDescriptionMethod());

            if (@enum.HasAttribute("Flags"))
            {
                classSb.AppendLine(GenerateAddFlag(@enum))
                    .AppendLine(GenerateRemoveFlag(@enum))
                    .AppendLine(GenerateContainsFlag(@enum));
            }
        }

        classSb.AppendLine("}");
        sb.AppendLine(string.Join("\n", usings))
            .AppendLine(@namespace)
            .AppendLine(classSb.ToString());

        var final = sb.ToString();

        context.AddSource("EnumExtensionsGeneratorGenerated.g.cs", final);
    }

    private string GenerateAddFlag(EnumDeclarationSyntax enumDeclarationSyntax)
    {
        var enumName = enumDeclarationSyntax.Identifier.ToString();
        return $$"""
                 /// <summary>
                 /// It will add the <paramref name="other"/> flag to the <paramref name="source"/> 
                 /// </summary>
                 /// <param name="source">The enum on which the flag will be added</param>
                 /// <param name="other">The other flag value</param>
                 /// <returns>{{enumName}} with the added <paramref name="other" /> </returns>
                 public static {{enumName}} AddFlag(this {{enumName}} source, {{enumName}} other)
                 {
                    source |= other;
                    return source;
                 }
                 """;
    }

    /// <summary>
    ///
    /// </summary>
    /// <param name="enumDeclarationSyntax"></param>
    /// <returns></returns>
    private string GenerateRemoveFlag(EnumDeclarationSyntax enumDeclarationSyntax)
    {
        var enumName = enumDeclarationSyntax.Identifier.ToString();
        return $$"""
                 /// <summary>
                 /// It will remove the <paramref name="other"/> flag from the <paramref name="source"/> 
                 /// </summary>
                 /// <param name="source">The enum from which the flag will be removed</param>
                 /// <param name="other">The other flag value</param>
                 /// <returns>{{enumName}} with the removed <paramref name="other" /> </returns>
                 public static {{enumName}} RemoveFlag(this {{enumName}} source, {{enumName}} other)
                 {
                    source &= ~other;
                    return source;
                 }
                 """;
    }


    private string GenerateContainsFlag(EnumDeclarationSyntax enumDeclarationSyntax)
    {
        var enumName = enumDeclarationSyntax.Identifier.ToString();
        return $"""
                /// <summary>
                /// It will check if the <paramref name="other"/> contains <paramref name="source"/> 
                /// </summary>
                /// <param name="source">The enum which will be checked</param>
                /// <param name="other">The other flag value</param>
                /// <returns>
                /// <c>true</c> if <paramref name="source"/>  contains <paramref name="other"/> otherwise <c>false</c>
                /// </returns>
                public static bool ContainsFlag(this {enumName} source, {enumName} other)
                   => (source & other) != 0;
                """;
    }
}