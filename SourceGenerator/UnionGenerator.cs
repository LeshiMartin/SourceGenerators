using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace SourceGenerator;

public class UnionAttribute : Attribute;

[Generator]
public class UnionGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var provider = context.SyntaxProvider.CreateSyntaxProvider(
            (node, _) => HasUnionAttribute(node),
            (syntaxContext, _) => Transform(syntaxContext)
        ).Where(x => x is not null);

        var compilation = context.CompilationProvider.Combine(provider.Collect());
        context.RegisterSourceOutput(compilation, Execute!);
    }

    private void Execute(SourceProductionContext context, (Compilation Left, ImmutableArray<Either> Right) arg2)
    {
        //if (!Debugger.IsAttached)
        //{
        //    Debugger.Launch();
        //}
        var (_, eithers) = arg2;
        if (eithers.IsEmpty) return;
        var nameSpace = "namespace {0};";
        const string comment = "// <auto-generated/>\n";

        const string start = "abstract partial {0} {1}";
        const string methodTemplate = "public abstract TR Match<TR>";
        foreach (var either in eithers)
        {
            var sb = new StringBuilder();
            var parent = either.Match(x => x.Parent, x => x.Parent);
            sb.Append(comment).AppendLine(string.Format(nameSpace,parent!.GetNamespaceName()));
            var (keyword, name) =
                either.Match(x => ("class", x.Identifier.ValueText),
                    x => ("record", x.Identifier.ValueText));
            sb.AppendLine(string.Format(start, keyword, name))
                .AppendLine("{")
                .AppendLine($"  private {name}() {{}}");
         
            
            var tuples = GetMemberTuples(either);
            var memberNamesArr = tuples.Select(x => x.memberName).Select(x => $"Func<{x},TR> on{x}");
            var methodArgs = string.Join(",", memberNamesArr);
            sb.AppendLine($"    {methodTemplate}( {methodArgs} );");

            foreach (var valueTuple in tuples)
            {
                var innerType = $$"""
                                    public sealed partial {{valueTuple.keyWord}} {{valueTuple.memberName}} : {{name}}
                                    {
                                    
                                        public override TR Match<TR>({{methodArgs}})
                                            => on{{valueTuple.memberName}}(this);
                                    }
                                 """;
                sb.AppendLine(innerType);

            }

            sb.AppendLine("}");

            var final = sb.ToString();

            context.AddSource($"{name}Generated.g.cs", final);

        }
    }


    private (string keyWord, string memberName)[] GetMemberTuples(Either either)
    {
        const string partialKeyword = "partial";
        return either.Match(
                 x => x.Members.Where(m => m.Modifiers.ToString().Contains(partialKeyword)).Select(GetMemberTuple),
                 x => x.Members.Where(m => m.Modifiers.ToString().Contains(partialKeyword)).Select(GetMemberTuple))
             .ToArray()!;
    }

    private (string keyWord, string memberName) GetMemberTuple(MemberDeclarationSyntax memberDeclaration)
        => memberDeclaration switch
        {
            RecordDeclarationSyntax recordDeclaration => ("record", recordDeclaration.Identifier.ValueText),
            ClassDeclarationSyntax classDeclaration => ("class", classDeclaration.Identifier.ValueText),
            _ => throw new ArgumentOutOfRangeException()
        };

    private Either? Transform(GeneratorSyntaxContext context)
        => context.Node switch
        {
            ClassDeclarationSyntax classDeclarationSyntax => classDeclarationSyntax,
            RecordDeclarationSyntax recordDeclarationSyntax => recordDeclarationSyntax,
            _ => null
        };

    private bool HasUnionAttribute(SyntaxNode syntaxNode)
        => syntaxNode switch
        {
            ClassDeclarationSyntax classDeclaration => classDeclaration.AttributeLists.Any(HasUnionAttribute),
            RecordDeclarationSyntax recordDeclaration => recordDeclaration.AttributeLists.Any(HasUnionAttribute),
            _ => false
        };

    private bool HasUnionAttribute(AttributeListSyntax attributeListSyntax)
        => attributeListSyntax.Attributes.Any(x =>
            x.Name.ToString().Equals("Union", StringComparison.InvariantCultureIgnoreCase));


    private class Either
    {
        private readonly ClassDeclarationSyntax? _classDeclaration;
        private readonly RecordDeclarationSyntax? _recordDeclaration;

        private readonly bool _isClass;

        public Either(ClassDeclarationSyntax classDeclaration)
        {
            _classDeclaration = classDeclaration;
            _isClass = true;
        }

        public Either(RecordDeclarationSyntax recordDeclaration)
        {
            _recordDeclaration = recordDeclaration;
        }

        public TR Match<TR>(Func<ClassDeclarationSyntax, TR> onClass, Func<RecordDeclarationSyntax, TR> onRecord)
            => _isClass ? onClass(_classDeclaration!) : onRecord(_recordDeclaration!);

        public static implicit operator Either(ClassDeclarationSyntax classDeclaration) => new(classDeclaration);
        public static implicit operator Either(RecordDeclarationSyntax recordDeclaration) => new(recordDeclaration);
    }
}